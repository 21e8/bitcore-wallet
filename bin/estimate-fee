#!/usr/bin/env node
var program = require('commander');
var https = require('https');

program
  .option('-t, --testnet', 'testnet/regtest network')
  .option('-k, --satsperkb', 'Provide output in satoshis/kB (1000 bytes) instead of satoshis/byte.')
  .option('-u, --url <url>', 'Provide an explicit url in which query for fee estimation. Must be https.')
  .usage('[options] e.g. estimate-fee 2 \nEstimate fee in satoshis/byte or satoshis/kB (1000 bytes).')
  .parse(process.argv);

var args = program.args;
var divideBy = program.satsperkb ? 1 : 1000;
var blocks = args[0] || '2';
var url = program.url || 'https://insight.bitpay.com/api/utils/estimateFee';


function getFeeEstimate(url, callback) {
  var self = this;
  var data = '';
  var req = https.request(url + "?nbBlocks=" + blocks, function(res) {
    var error;
    res.on('data', function(chunk) {
      data += chunk;
    });
    res.on('error', function(err) {
      error = err;
    });
    res.on('end', function() {
      if (error) {
        return callback(err);
      }
      var parsedObj;
      try {
        parsedObj = JSON.parse(data);
      } catch(e) {
        return callback(e);
      }
      callback(null, parsedObj);
    });
  });
  req.write('');
  req.end();
}

getFeeEstimate(url, function(err, fee) {
  if(err) {
    throw err;
  }
  var rate = Object.keys(fee)[0];
  //TODO: standardize how bitcoin/satoshi amounts are dealt with
  var satsperkb = Math.round(parseFloat(fee[rate] * 1E8));
  rate = Math.round(satsperkb / divideBy);
  process.stdout.write(JSON.stringify({fee: rate}));
});

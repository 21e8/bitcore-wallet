#!/usr/bin/env node

/*
input file format:
{ utxos: [ { txid: <txid>, vout: <int>, satoshis: <int>, scriptPubKey: <hex> }, ... ],
  addresses: [ { address: <address>, satoshis: <OPTIONAL int>, changeAddress: <bool> }, ... ] }
*/
var program = require('commander');
var bitcore = require('bitcore-lib');
var fs = require('fs');
var _ = require('lodash');
var inputFileFormat = '{ utxos: [ { txid: <txid>, vout: <int>, satoshis: <int>, scriptPubKey: <hex> }, ... ],\n' +
'addresses: [ { address: <addresses>, satoshis: <OPTIONAL int>, changeAddress: <bool> }, ... ] }';

program
  .option('-s, --maxtxsize <maxtxsize>', 'Maximum Transaction Size in bytes, default 100 kB')
  .option('-a, --maxsatoshis <maxsatoshis>', 'Maximum Satoshis, default 50 BTC')
  .option('-f, --feeperbyte <feeperbyte>', 'Specify a fee per byte')
  .usage('<input file> <tx output file or stdout>, e.g. wallet-create-transaction input.json tx.hex\n\nInput file format ' +
  inputFileFormat + '\n\nOutputs:\n\nIf the satoshis field is null, then the amount sent will be chosen based on the input ' +
  'amounts.\n\nIf the output address is a change address, then the satoshis field will be ignored.\n\n' +
  'If the fee plus the other output amounts are still less than the sum of the inputs, the balance will be applied to the change address.')
  .parse(process.argv);

var BitcoreWalletTransaction = function(options) {
  this.program = options.program;
  this.args = this.program.args;
  this._processArgs();
  this.inputFile = this.args[0];
  this.outputFile = this.args[1];
  this.maxTxSize = options.maxtxsize || 1E5;
  this.maxSatoshis = options.maxsatoshis || 50 * 1E8;
  this.feeperbyte = options.feeperbyte;
  this.inputAmount = 0;
  this.outputAmount = 0;
  this.signatureByteLength = 72;
};

BitcoreWalletTransaction.prototype._processArgs = function() {
  if (!this.args[0]) {
    this.program.help();
  } else if (this.args[1] && fs.existsSync(this.args[1])) {
    console.error('Output file: "' + this.args[1] + '" already exists, not over-writing, aborting.');
    process.exit(-1);
  }
};

BitcoreWalletTransaction.prototype._setInputInformation = function() {
  //letting this throw if needed
  var inputInfo = require(this.inputFile);
  this._addresses = inputInfo.addresses;
  this.utxos = inputInfo.utxos;
};

BitcoreWalletTransaction.prototype._writeOutputFile = function(callback) {
  var data = JSON.stringify({ tx: this.tx.uncheckedSerialize() });
  if (this.outputFile) {
    fs.open(this.outputFile, 'wx', function(err, fd) {
      if (err) {
        return callback(err);
      }
      fs.write(fd, data, function(err) {
        if(err) {
          return callback(err);
        }
        callback();
      });
    });
  } else {
    setImmediate(function() {
      process.stdout.write(data);
      callback();
    });
  }
};

BitcoreWalletTransaction.prototype._addInputs = function() {
  var utxos = [];
  for(var i = 0; i < this.utxos.length; i++) {
    if (!this._isP2PKH(this.utxos[i])) {
      continue;
    } else if (!this._hasInputSpace(this.utxos[i]) ||
      !this._hasInputAmount(this.utxos[i])) {
      break;
    }
    this.inputAmount += this.utxos[i].satoshis;
    utxos.push(this.utxos[i]);
  }
  this.tx.from(utxos);
};

BitcoreWalletTransaction.prototype._addOutputs = function() {
  for(var i = 0; i < this._addresses.length; i++) {
    var amount = this._getOutputAmount(this._addresses[i]);
    this.outputAmount += amount
    this.tx.to(this._addresses[i].address, amount);
  }
};

BitcoreWalletTransaction.prototype._getOutputAmount = function(addr) {
    //if there is no amount for the output -and- this is listed as a change address, then this is good to go
    //if there is no amount for the output -and- there is more than one non-change output containing a null value for the amount, then this is an error and we cannot continue. The output amount are ambiguous (we don't know how much to sent to each non-change output)
  var unsetOutputAmount = !addr.changeAddress && !addr.satoshis;
  if (unsetOutputAmount && this._unsetOutputAmounts > 0) {
    throw 'Supplied output address(es) amounts are ambiguous, please check the "satoshis" field, aborting.';
  }
  if (unsetOutputAmount) {
    this._unsetOutputAmounts++;
  }
  return (unsetOutputAmount || addr.changeAddress) ? 0 : addr.satoshis;
};

BitcoreWalletTransaction.prototype._isP2PKH = function(utxo) {
  var script = new bitcore.Script(utxo.scriptPubKey);
  return script.isPublicKeyHashOut();
};

BitcoreWalletTransaction.prototype._hasInputAmount = function(utxo) {
  return (this.tx.inputAmount + utxo.satoshis) <= this.maxSatoshis;
};

BitcoreWalletTransaction.prototype._hasInputSpace = function(utxo) {
  return (this.tx.uncheckedSerialize().length + this._calculateSigSpace(utxo)) <= this.maxTxSize;
};

BitcoreWalletTransaction.prototype._calculateSigSpace = function(utxo) {
  //TODO: redeem scripts come into play here to deal with P2SH
  return (this.tx.inputs.length + 1) * this.signatureByteLength;
};

BitcoreWalletTransaction.prototype._setFee = function() {
  var fee = this.feeperbyte || 140;
  this.tx.fee(this.tx.uncheckedSerialize().length * fee);
};

BitcoreWalletTransaction.prototype._setDeferredOutputAmounts = function() {
  for(var i = 0; i < this.tx.outputs.length; i++) {

  }

};

BitcoreWalletTransaction.prototype._checkAmounts = function() {
  if (this.outputAmount > (this.inputAmount - this.tx.getFee())) {
    throw 'Output amounts exceed input amounts.';
  }
};

BitcoreWalletTransaction.prototype._createTransaction = function() {
  this.tx = new bitcore.Transaction();
};

BitcoreWalletTransaction.prototype._generateStats = function() {
  var stats = '';
  stats += 'Total BTC sent: ' + (this.inputAmount / 1E8).toFixed(8) + '\n';
  stats += 'Number of output addresses: ' + this._addresses.length + '\n';
  stats += 'Total fees in satoshis: ' + this.tx.getFee() + '\n';
  stats += 'Total size in bytes: ' + this.tx.uncheckedSerialize().length + '\n';
  stats += 'Satoshis per byte: ' + Math.ceil(this.tx.getFee() / this.tx.uncheckedSerialize().length) + '\n';
  return stats;
};

BitcoreWalletTransaction.prototype.createTransaction = function(callback) {
  var self = this;
  //set output addresses, amounts and utxos
  self._setInputInformation();
  //create empty tx
  self._createTransaction();
  //add outputs
  self._addOutputs();
  //add inputs
  self._addInputs();
  //set fee
  self._setFee();
  //set deferred output amounts
  self._setDeferredOutputAmounts
  //check amounts
  self._checkAmounts(); //throws
  //write tx
  self._writeOutputFile(function(err) {
    if(err) {
      return callback(err);
    }
    callback(null, self._generateStats());
  });
};

if (require.main === module) {

  var bitcoreWalletTransaction = new BitcoreWalletTransaction({
    program: program
  });

  bitcoreWalletTransaction.createTransaction(function(err, stats) {
    if(err) {
      throw err;
    }
    if (bitcoreWalletTransaction.outputFile) {
      console.log(stats);
    }
  });

}

module.exports = BitcoreWalletTransaction;

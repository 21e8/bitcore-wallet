#!/usr/bin/env node

var program = require('commander');
var utils = require('./cli-utils');
var bitcore = require('bitcore-lib');
var fs = require('fs');
var _ = require('lodash');

program = utils.configureCommander(program);
program
  .option('-s, --maxtxsize <maxtxsize>', 'Maximum Transaction Size in bytes, default 100 kB')
  .option('-a, --maxsatoshis <maxsatoshis>', 'Maximum Satoshis, default 50 BTC')
  .usage('wallet-create-transactions <utxo file> <destination info file> <tx output file or stdout>, e.g. wallet-create-transaction utxos.json dest.json tx.hex')
  .parse(process.argv);

var BitcoreWalletTransaction = function(options) {
  this.program = options.program;
  this.args = this.program.args;
  this.utxoFile = this.args[0];
  this.addressesFile = this.args[1];
  this.maxTxSize = options.maxtxsize || 1E5;
  this.maxSatoshis = options.maxsatoshis || 50 * 1E8;
};

BitcoreWalletTransaction.prototype._processArgs = function() {
  if (!this.args[0] || !this.args[1] || (this.args[2] && !fs.existsSync(this.args[2]))) {
    this.program.help();
  }
};

BitcoreWalletTransaction.prototype._setOutputAddressesAndAmounts = function() {
  //letting this throw if needed
  this._addresses = require(this.addressesFile);
};

BitcoreWalletTransaction.prototype._setUtxos = function(callback) {
  //letting this throw if needed
  this._sortUtxos(require(this.utxoFile));
};

BitcoreWalletTransaction.prototype._writeOutputFile = function(callback) {
  fs.open(file, 'wx', function(err, fd) {
    if (err) {
      return callback(err);
    }
    fs.write(fd, data, function(err) {
      if(err) {
        return callback(err);
      }
      callback();
    });
  });
};

BitcoreWalletTransaction.prototype._sortUtxos = function(utxos) {
  this.utxos = _.sortBy(utxos, [function(utxo) {
    if (utxo) {
      return utxo.satoshis;
    }
  }]);
};

BitcoreWalletTransaction.prototype._addInputs = function() {
  var utxos = [];
  for(var i = 0; i < this.utxos.length; i++) {
    if (!this._hasInputSpace(this.utxos[i])) {
      break;
    }
    utxos.push(this.utxos[i]);
  }
  this.tx.from(utxos);
};

BitcoreWalletTransaction.prototype._addOutputs = function() {
  for(var i = 0; i < this._addresses.length; i++) {
    this.tx.to(this._addresses[i].address, this._addresses[i].amount);
  }
};

BitcoreWalletTransaction.prototype._hasInputSpace = function(utxo) {
  return (this.tx.uncheckedSerialize().length + this._calculateSigSpace(utxo)) <= this.maxTxSize;
};

BitcoreWalletTransaction.prototype._calculateSigSpace = function(utxo) {
  return (this.tx.inputs.length + 1) * 72;
};

BitcoreWalletTransaction.prototype._estimateFee = function() {
  return 0;
};

BitcoreWalletTransaction.prototype._checkAmounts = function() {
  var fee = this.getFee();
  if (fee < this._fee) {
    throw 'Output amounts exceed input amounts.'
  }
  return fee;
};

BitcoreWalletTransaction.prototype._createTransaction = function() {
  this.tx = new bitcore.Transaction();
};

BitcoreWalletTransaction.prototype.createTransaction = function(callback) {
  var self = this;
  //get utcos
  self._setUtxos();
  //set output addresses and amounts
  self._setOutputAddressesAndAmounts();
  //create empty tx
  self._createTransaction();
  //add outputs
  self._addOutputs();
  //add inputs
  self._addInputs();
  //get fee
  self._estimateFee();
  //check amounts
  self._checkAmounts(); //throws
  //serialize tz
  self._serialTransaction();
  //write tx
  self._writeOutputFile(function(err) {
    if(err) {
      return callback(err);
    }
    callback(null, self._generateStats());
  });
};

if (require.main === module) {

  var bitcoreWalletTransaction = new BitcoreWalletTransaction({
    program: program
  });

  bitcoreWalletTransaction.createTransaction(function(err, stats) {
    if(err) {
      throw err;
    }
    console.log(stats);
  });

}

module.exports = BitcoreWalletTransaction;

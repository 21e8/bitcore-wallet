#!/usr/bin/env node

/*
input file format:
{ utxos: [ { txid: <txid>, vout: <int>, <amount | satoshis>: <int>, scriptPubKey: <hex> }, ... ],
addresses: [ { address: <address>, <amount | satoshis>: <OPTIONAL int>, changeAddress: <bool> }, ... ],
fee: <int>
}
*/
var program = require('commander');
var bitcore = require('bitcore-lib');
var https = require('https');
var path = require('path');
var fs = require('fs');
var _ = require('lodash');
var async = require('async');

var inputFileFormat = '{ utxos: [ { txid: <txid>, vout: <int>, satoshis: <int>, scriptPubKey: <hex> }, ... ],\n' +
'addresses: [ { address: <addresses>, satoshis: <OPTIONAL int>, changeAddress: <bool> }, ... ] }';

program
  .option('-s, --maxtxsize <maxtxsize>', 'Maximum Transaction Size in bytes, default 100 kB (100,000 bytes)')
  .option('-a, --maxamount <maxamount>', 'Maximum BTC Amount, default 50 BTC')
  .option('-p, --priority <priority>', 'Generally equates how quickly this transaction could be confirmed. 1-3, with 1 being the highest priority')
  .usage('<input file> <tx output file or stdout>, e.g. wallet-create-transaction input.json tx.hex\n\nInput file format ' +
  inputFileFormat + '\n\n\n' + fs.readFileSync(__dirname + '/../TransactionRules.txt'))
  .parse(process.argv);

var BitcoreWalletTransaction = function(options) {
  this.program = options.program;
  this.args = this.program.args;
  this._processArgs();
  this.inputFile = path.resolve(__dirname, '../' + this.args[0]);
  this.outputFile = this.args[1];
  this.maxTxSize = this.program.maxtxsize || 1E5;
  this.signatureByteLength = 72; //this is worst case size, actual size could be -2 byte
  this.priority = this.program.priority;
  this.outputAmount = 0;
  this.bitcoinMinOutputAmount = 4000; //the real value is 1000 sats, but x4 for a more sane value minimum
};

BitcoreWalletTransaction.prototype._checkProvidedFeeRate = function() {
  if (!this.feeperbyte && this.feeperbyte !== 0) {
    throw 'Fee rate was not passed in.';
  }
};

BitcoreWalletTransaction.prototype._setUtxoAmounts = function() {
  for(var i = 0; i < this.utxos.length; i++) {
    this.utxos[i].satoshis = this.utxos[i].satoshis || this._convertBTCToSat(this.utxos[i].amount);
  }
};

BitcoreWalletTransaction.prototype._filterUtxos = function() {
  var self = this;
  this.utxos = _.filter(this.utxos, function(utxo) {
    return utxo.satoshis <= self.maxSatoshis && self._isP2PKH(utxo);
  });
};

BitcoreWalletTransaction.prototype._sortUtxos = function() {
  this.utxos = _.sortBy(this.utxos, 'satoshis').reverse();
};

BitcoreWalletTransaction.prototype._setOutputAmounts = function() {
  for(var i = 0; i < this._addresses.length; i++) {
    var address = this._addresses[i];
    if (!address.changeAddress) {
      if (address.amount) {
        address.satoshis = this._convertBTCToSat(address.amount);
      }
      if (!address.satoshis) {
        address.satoshis = 0;
        this.deferredOutputsNeeded = true;
      }
      this.outputAmount += address.satoshis;
    }
  }
  if (this.program.maxamount) {
    this.maxSatoshis = this._convertBTCToSat(this.program.maxamount);
  } else {
    this.maxSatoshis = this._convertBTCToSat(50);
  }
};

BitcoreWalletTransaction.prototype._processArgs = function() {
  if (!this.args[0]) {
    this.program.help();
  } else if (this.args[1] && fs.existsSync(this.args[1])) {
    console.error('Output file: "' + this.args[1] + '" already exists, not over-writing, aborting.');
    process.exit(-1);
  }
};

BitcoreWalletTransaction.prototype._setInputInformation = function() {
  //letting this throw if needed
  var inputInfo = require(this.inputFile);
  this._addresses = inputInfo.addresses;
  this.utxos = inputInfo.utxos;
  this.feeperbyte = inputInfo.fee;
};

BitcoreWalletTransaction.prototype._performSanityChecks = function() {
  var notGood = !this.utxos ||
                this.utxos.length === 0 ||
               !this._addresses ||
               this._addresses.length === 0 ||
               !this._sufficientInputs();
  if (notGood) {
    throw 'Inputs amounts cannot satify the output amounts.';
  }
};

BitcoreWalletTransaction.prototype._sufficientInputs = function() {
  //user did not set output therefore any inputs will satisfy
  if (this.outputAmount === 0) {
    return true;
  }
  var inAmount = 0;
  for(var i = 0; i < this.utxos.length; i++) {
    inAmount += this.utxos[i].satoshis || 0;
  }
  //this is just a sanity check and won't factor in a fee
  if (inAmount > this.outputAmount) {
    return true;
  }
  return false;
};

BitcoreWalletTransaction.prototype._writeOutputFile = function(callback) {
  var data = JSON.stringify({ tx: this.tx.uncheckedSerialize() });
  if (this.outputFile) {
    fs.open(this.outputFile, 'wx', function(err, fd) {
      if (err) {
        return callback(err);
      }
      fs.write(fd, data, function(err) {
        if(err) {
          return callback(err);
        }
        callback();
      });
    });
  } else {
    setImmediate(function() {
      process.stdout.write(data);
      callback();
    });
  }
};

BitcoreWalletTransaction.prototype._addInputs = function() {
  //if output amounts are EXPLICITLY set, then we MUST satisfy those.
  //we must also provide a fee, which will require additional inputs apart from those that satisfy the specified outputs.
  //the above contraints are secondary to the max space limitation and the max satoshis limitation
  for(var i = 0; i < this.utxos.length; i++) {

    if (!this._hasInputSpace(this.utxos[i]) ||
      this._hasSurpassedMaxSatoshis(this.utxos[i]) ||
      this._hasEnoughInputsForOutputs(this.utxos[i])) {
      continue;
    }

    this.tx.from(this.utxos[i]);
  }
};

BitcoreWalletTransaction.prototype._addOutputs = function() {
  for(var i = 0; i < this._addresses.length; i++) {

    var output = this._addresses[i];

    if (!output.changeAddress) {

      this.tx.to(output.address, output.satoshis);

    } else {
      if (this._changeAddressIndex >= 0) {
        throw 'multiple change addresses were given in inputs, aborting.';
      } else {
        this._changeAddressIndex = i;
      }
    }
  }
};

BitcoreWalletTransaction.prototype._isP2PKH = function(utxo) {
  var script = new bitcore.Script(utxo.scriptPubKey);
  return script.isPublicKeyHashOut();
};

BitcoreWalletTransaction.prototype._hasEnoughInputsForOutputs = function(utxo) {
  //if we add this utxo, will the sum of the inputs be equal to or less than projected fees plus the outputAmount
  //TRUE === DO NOT ADD TO INPUTS!!!
  if (this.outputAmount === 0) {
    return false; //this means the user did not set the output amount. This Tx is a sweep where the output amounts are not important
  }
  var inputAmountWithThisUtxo = this.tx.inputAmount + utxo.satoshis;
  var feePlusOutputAmount = this._calculateRunningFee(utxo) + this.outputAmount;
  //by adding this utxo, we overshoot the input amounts, the balance becomes the amount in the change address
  //we would like to not use a change address, but we almost always have to anyway
  var overshot = inputAmountWithThisUtxo > feePlusOutputAmount;
  if (overshot && !this.inputAmountOvershot) {
    this.inputAmountOvershot = true;
    return false;
  }
  return overshot;
};

BitcoreWalletTransaction.prototype._hasSurpassedMaxSatoshis = function(utxo) {
  //if we add this utxo, will the sum of the input amounts be greater than or equal to the maxSatoshis?
  //if true, then we must NOT add this utxo to the tx
  var txAmountWithThisUtxo = this.tx.inputAmount + utxo.satoshis;
  var ret = txAmountWithThisUtxo > this.maxSatoshis;
  return ret;
};

BitcoreWalletTransaction.prototype._calculateRunningFee = function(utxo) {
  var num = utxo ? 1 : 0;
  var extraSpaceForChangeAddress = 0;
  if (this._changeAddressIndex >= 0) {
    extraSpaceForChangeAddress = 34;
  }
  var runningFee = (this._getTxSize() + this._calculateSigSpace(num) + extraSpaceForChangeAddress) * this.feeperbyte;
  return runningFee;
};

BitcoreWalletTransaction.prototype._hasInputSpace = function(utxo) {
  //if we add this utxo, will the total tx size (less a change address output) be greater than or equal to the maxTxSize
  //if false, then we must NOT add this utxo to the tx
  var ret = (this._getTxSize() + this._calculateSigSpace(1)) <= this.maxTxSize;
  return ret;
};

BitcoreWalletTransaction.prototype._calculateSigSpace = function(num) {
  return (this.tx.inputs.length + num) * this.signatureByteLength;
};

BitcoreWalletTransaction.prototype._setFee = function() {
  this.tx.fee(this._calculateRunningFee());
};

BitcoreWalletTransaction.prototype._getRemoteData = function(url, callback) {
  var self = this;
  var data = '';
  var req = https.request(url, function(res) {
    var error;
    res.on('data', function(chunk) {
      data += chunk;
    });
    res.on('error', function(err) {
      error = err;
    });
    res.on('end', function() {
      if (error) {
        return callback(err);
      }
      var parsedObj;
      try {
        parsedObj = JSON.parse(data);
      } catch(e) {
        return callback(e);
      }
      callback(null, parsedObj);
    });
  });
  req.write('');
  req.end();
};

BitcoreWalletTransaction.prototype._setDeferredOutputs = function() {
  //all outputs that have a zero amount will retain
  if (!this.deferredOutputsNeeded) {
    return;
  }

  var outputsToPopulate = [];
  var amountAlreadyPopulated = 0;
  for(var i = 0; i < this.tx.outputs.length; i++) {
    var output = this.tx.outputs[i];
    if (output.satoshis === 0) {
      outputsToPopulate.push(output);
      continue;
    }
    amountAlreadyPopulated += output.satoshis;
  }

  if (outputsToPopulate.length < 1) {
    return;
  }

  amountAlreadyPopulated += this.tx.getFee();
  var amountToDivideUpBetweenZeroOutputs = this.tx.inputAmount - amountAlreadyPopulated;
  var amountsToSet = this._getValueForZeroOutputs(amountToDivideUpBetweenZeroOutputs, outputsToPopulate.length);
  if (!amountsToSet) {
    throw 'Attempting to set outputs with amounts that are too small to send to the network.';
  }

  for(var j = 0; j < outputsToPopulate.length; j++) {
    if (j === 0) {
      outputsToPopulate[j].satoshis = amountsToSet[0] + amountsToSet[1];
    } else {
      outputsToPopulate[j].satoshis = amountsToSet[0];
    }
  }

};

BitcoreWalletTransaction.prototype._getValueForZeroOutputs = function(amount, numOutputs) {
  var value = Math.floor(amount / numOutputs);
  var remainder = amount % numOutputs;
  if (value < this.bitcoinMinOutputAmount) {
    return;
  }
  return [value, remainder];
};

BitcoreWalletTransaction.prototype._setChangeAddress = function() {
  if (this._changeAddressIndex >= 0 && !this.deferredOutputsNeeded) {
    this.tx.change(this._addresses[this._changeAddressIndex].address);
  }
};

BitcoreWalletTransaction.prototype._getExchangeRate = function(callback) {
  var self = this;
  self._getRemoteData('https://bitpay.com/api/rates/usd', function(err, rates) {
    if(err) {
      return callback(err);
    }
    if (rates.rate) {
      self.feeInUSD = (rates.rate * self._convertSatToBTC(self.tx.getFee())).toFixed(2);
      return callback();
    }
    callback(new Error('response has no USD rate'));
  });
};

BitcoreWalletTransaction.prototype._getOutputAmounts = function() {
  var nonChangeAmount = 0;
  var changeAmount = 0;
  for(var i = 0; i < this.tx.outputs.length; i++) {
    var output = this.tx.outputs[i];
    if (this._changeAddressIndex >= 0 &&
      this._addresses[this._changeAddressIndex].address === output.script.toAddress().toString()) {
        changeAmount += output.satoshis;
    } else {
      nonChangeAmount += output.satoshis;
    }
  }
  return { changeAmount: changeAmount, nonChangeAmount: nonChangeAmount };
};

BitcoreWalletTransaction.prototype._checkAmounts = function() {
  if ((this.tx.outputAmount + this.tx.getFee()) > this.tx.inputAmount) {
    var errStr = 'Inputs, fees and outputs did not balance during final check. This could be because we could not add enough inputs due to limitations of max size or max satoshis.\n\nMax Satoshis: ' + this.maxSatoshis + '\nMax Size: ' + this.maxTxSize + '\nOutput Amt: ' + this.tx.outputAmount + '\nInput Amt: ' + this.tx.inputAmount + '\nFee Amt: ' + this.tx.getFee() + '\nTotal Input Amt Needed: ' + (this.tx.outputAmount + this.tx.getFee()) + '\nTotal Input Amt Supplied: ' + this.tx.inputAmount;
    throw errStr;
  }
};

BitcoreWalletTransaction.prototype._printAmountsForEachOutput = function() {
  var str = '';
  for(var i = 0; i < this.tx.outputs.length; i++) {
    str += 'Output ' + i + ' (' + this.tx.outputs[i].script.toAddress().toString() + '): ' + this._convertSatToBTC(this.tx.outputs[i].satoshis) + ' BTC\n';
  }
  return str;
};

BitcoreWalletTransaction.prototype._createTransaction = function() {
  this.tx = new bitcore.Transaction();
};

BitcoreWalletTransaction.prototype._convertBTCToSat = function(btc) {
  return Math.round(btc * 1E8);
};

BitcoreWalletTransaction.prototype._convertSatToBTC = function(sats) {
  return (sats / 1E8).toFixed(8);
};

BitcoreWalletTransaction.prototype._getTxSize = function() {
  return this.tx.toBuffer().length;
};

BitcoreWalletTransaction.prototype._generateStats = function() {
  var outputAmounts = this._getOutputAmounts();
  var stats = '';
  stats += 'Total BTC sent: ' + this._convertSatToBTC(this.tx.inputAmount) + '\n';
  stats += 'Number of output addresses: ' + this.tx.outputs.length + '\n';
  stats += 'BTC amount sent to non-change address(es): ' + this._convertSatToBTC(outputAmounts.nonChangeAmount) + '\n';
  stats += 'BTC amount sent to each non-change address:\n' + this._printAmountsForEachOutput();
  stats += 'BTC amount sent to change address: ' + this._convertSatToBTC(outputAmounts.changeAmount) + '\n';
  stats += 'Number of inputs used: ' + this.tx.inputs.length + '\n';
  stats += 'Total fees in BTC: ' + this._convertSatToBTC(this.tx.getFee()) + '\n';
  stats += 'Total fees in USD: $' + this.feeInUSD + '\n';
  stats += 'Total size in bytes: ' + this._getTxSize() + '\n';
  stats += 'Fee as satoshis per byte: ' + Math.ceil(this.tx.getFee() / (this._getTxSize() + this._calculateSigSpace(0))) + '\n';
  return stats;
};

//these are all P2PKH inputs at 147 bytes, the outputs are typically 34 bytes
//how many inputs are we going to need to satify the outputs and the fee?
//will we need a change address?

//If the user doesn't set an output amount, then things become dramatically easier, so figure this out right away

//If no output set, then we just need to worry about max size and max amount, but NO CHANGE address

//If outputs set, we need to check if we have the inputs to satisfy them and the fee, the more inputs used, the greater the fee needed. There will also be a change address needed, most likely
//If the utxos are sorted highest to lowest, this makes things cheaper
BitcoreWalletTransaction.prototype.createTransaction = function(callback) {
  var self = this;
  //set output addresses, amounts and utxos
  self._setInputInformation();
  //set provided fee amount (this util does not decide what fees to add, user must pass in
  self._checkProvidedFeeRate();
  //set the max output amount
  self._setOutputAmounts();
  //deal with utxos that have an amount field in btc
  self._setUtxoAmounts();
  //filter utxos
  self._filterUtxos();
  //perform sanity checks on the inputs/outputs
  self._performSanityChecks();
  //sort utcos, high amt to low
  self._sortUtxos();
  //create empty tx
  self._createTransaction();
  //add outputs
  self._addOutputs();
  //add inputs
  self._addInputs();
  //set fee
  self._setFee();
  //set outputs that weren't passed in explicitly
  self._setDeferredOutputs();
  //set change address output
  self._setChangeAddress();
  //check amounts
  self._checkAmounts(); //throws
  //write tx
  self._writeOutputFile(function(err) {
    if(err) {
      return callback(err);
    }
    self._getExchangeRate(function(err) {
      if(err) {
        return callback(err);
      }
      callback(null, self._generateStats());
    });
  });
};

if (require.main === module) {

  var bitcoreWalletTransaction = new BitcoreWalletTransaction({
    program: program
  });

  bitcoreWalletTransaction.createTransaction(function(err, stats) {
    if(err) {
      throw err;
    }
    if (bitcoreWalletTransaction.outputFile) {
      console.log(stats);
    }
  });

}

module.exports = BitcoreWalletTransaction;

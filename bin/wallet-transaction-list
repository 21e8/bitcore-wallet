#!/usr/bin/env node

var program = require('commander');
var http = require('http');
var https = require('https');
var fs = require('fs');
var url = require('url');

function isTLS(url) {
  return url.protocol === 'https:';
}

program
  .option('-u, --url <url>', 'Server url to register with. Default: http://localhost:3001')
  .option('-f, --file <walletFile>', 'Wallet file to use. Default: ~/.wallet.json')
  .option('-d, --dates <dates>', 'Date range. Default: all-time')
  .usage('[options] e.g. wallet-transactions-list -f wallet.json -u http://localhost:3001 <output file or stdout>')
  .parse(process.argv);

function writeOutputFile(file, data, callback) {
  fs.open(file, 'wx', function(err, fd) {
    if (err) {
      return callback(err);
    }
    fs.write(fd, data, function(err) {
      if(err) {
        return callback(err);
      }
      callback();
    });
  });
}

var args = program.args;
if (args[0] && fs.existsSync(args[0])) {
  console.error('Output file: "' + args[0] + '" already exists, not over-writing, aborting.');
  process.exit(-1);
}
var walletJSON = JSON.parse(fs.readFileSync(program.file));
var walletId = walletJSON.walletId;
var urlStr = program.url || 'http://localhost:3001';

var dateRange = parseDateRange(program.dates);

function getTransactionList(walletId, dateRange, callback) {
  var parsedUrl = url.parse(urlStr);
  var httpOptions = {
    protocol: parsedUrl.protocol,
    hostname: parsedUrl.hostname,
    port: parsedUrl.port || (isTLS(parsedUrl) ? 443 : 80),
    method: 'GET',
    url: urlStr,
    path: '/wallet-api/wallets/' + walletId + '/transactions?start=' +  dateRange[0].getTime() + '&end=' + dateRange[1].getTime(),
    params: { start: dateRange[0], end: dateRange[1] },
    body: ''
  };
  console.log(httpOptions);

  var error;
  var req = (isTLS(parsedUrl) ? https : http).request(httpOptions, function(res) {

    function finish(err, body) {
      if (err) {
        return callback(err);
      }
      if (res.statusCode < 200 || res.statusCode > 299) {
        return callback(new Error('Response code from server was ' + res.statusCode));
      }
      var json;
      if (body) {
        try {
          json = JSON.parse(body);
        } catch(e) {
          return callback(e);
        }
        if (json.transactions) {
          return callback(null, json.transactions);
        } else {
          return callback(new Error('Response json not as expected - no transactions key in reply: ' + body));
        }
      }
      callback(new Error('no body in response.'));
    }

    var body = '';
    res.on('data', function(chunk) {
      body += chunk;
    });

    res.on('end', function() {
      finish(error, body);
    });

  });

  req.on('error', function(e) {
    error = e;
  });

  req.write('');
  req.end();
}

function parseDateRange(range) {
  var dates = range.split(/\s+/);
  return dates.map(function(date) {
    return new Date(date);
  });
}

getTransactionList(walletId, dateRange, function(err, transactions) {
  if(err) {
    throw err;
  }
  var data = JSON.stringify(transactions);
  if (args[0]) {
    writeOutputFile(args[0], data, function(err) {
      if(err) {
        throw err;
      }
      console.log('Transactions written to ' + args[0] + ' for walletId: ' + walletId);
    });
  } else {
    setImmediate(function() {
      process.stdout.write(JSON.stringify(data));
    });
  }
});



#!/usr/bin/env node

var program = require('commander');
var path = require('path');
var fs = require('fs');
var async = require('async');
var utils = require('../util/crypto-functions.js');
var Hash = require('bitcore-lib').crypto.Hash;
var Transaction = require('bitcore-lib').Transaction;
var PublicKey = require('bitcore-lib').PublicKey;
var PrivateKey = require('bitcore-lib').PrivateKey;
var assert = require('assert');

program
  .option('-f, --walletfile <walletfile>', 'Wallet file to refer to for private keys. Default: ~/.wallet.json')
  .usage('[options] e.g. wallet-sign-nonhd -f wallet.json <input tx file> <output signed tx file>')
  .parse(process.argv);

var args = program.args;
if (!args[0]) {
  program.help();
}


function readInputFiles(file1, file2) {
  return [file1, file2].map(function(file) {
    return require(file);
  });
}

function setOutputFile(file) {
  if (fs.existsSync(file)) {
    console.error('Output file: "' + file + '" already exists, not over-writing, aborting.');
    process.exit(-1);
  }
  return file || process.stdout;
}

function decryptMasterKey(walletMap, callback) {
  utils.getPassphrase(function(err, passphrase) {

    if(err) {
      return callback(err);
    }

    var opts = {
      cipherText: walletMap.masterKey.cipherText,
      passphrase: passphrase,
      salt: walletMap.masterKey.salt,
      derivationOptions: {
        rounds: walletMap.masterKey.rounds,
        method: 0
      }
    };

    console.log('starting to decrypt master key...');
    var start = process.hrtime();
    var plainTextMasterKey = utils.decryptSecret(opts);
    console.log(utils.diffTime(start) + ' secs');

    return plainTextMasterKey ? callback(null, plainTextMasterKey) :
      callback(new Error('Master Key could not be decrypted.'));

  });
}

function getInputAddresses(tx, network) {
  var addresses = [];
  console.log('starting to gather input addresses...');
  var start = process.hrtime();
  for(var i = 0; i < tx.inputs.length; i++) {
    var input = tx.inputs[i];
    addresses.push(input.output.script.toAddress(network).toString());
  }
  console.log(utils.diffTime(start) + ' secs');
  return addresses;
}

function decryptNecessaryPrivateKeys(masterKey, walletMap, addresses) {
  var pks = [];

  console.log('starting to decrypt private keys...');
  var pubKeyTime = 0;
  var decryptTime = 0;
  for(var i = 0; i < walletMap.keys.length; i++) {
    var key = walletMap.keys[i];
    var start = process.hrtime();
    pubKeyTime += utils.diffTime(start);

    if (addresses.indexOf(key.address) === -1) {
      continue;
    }

    var start = process.hrtime();
    pks.push(new PrivateKey(utils.decrypt({
      cipherText: key.cipherText,
      key: masterKey,
      iv: Hash.sha256sha256(new Buffer(key.pubKey, 'hex'))
    })));
    decryptTime += utils.diffTime(start);
  }
  console.log('pubkey time: ' + pubKeyTime + ' secs');
  console.log('decrypt time: ' + decryptTime + ' secs');

  return pks;
}

function writeOutputFile(file, tx, callback) {
  var data = JSON.stringify({ rawtx: tx.serialize({ disableLargeFees: true }) });
  if (file !== process.stdout) {
    fs.open(file, 'wx', function(err, fd) {
      if (err) {
        return callback(err);
      }
      fs.write(fd, data, function(err) {
        if(err) {
          return callback(err);
        }
        console.log('signed tx written');
        callback();
      });
    });
  } else {
    setImmediate(function() {
      process.stdout.write(data);
      callback();
    });
  }
}

var outputFile = setOutputFile(args[1]);

var walletFile = program.walletfile ?
  path.resolve(__dirname, '../' + program.walletfile) :
  process.env.HOME + '/.wallet.json';

var inputFile = path.resolve(__dirname, '../' + args[0]);
var inputs = readInputFiles(inputFile, walletFile);
var walletMap = inputs[1];
var txJson = inputs[0];
var tx = new Transaction(txJson.rawtx);

var inputAddresses = getInputAddresses(tx, walletMap.network);

decryptMasterKey(walletMap, function(err, plainTextMasterKey) {

  if(err) {
    throw err;
  }

  var decryptedPrivateKeys = decryptNecessaryPrivateKeys(plainTextMasterKey, walletMap, inputAddresses);

  console.log('starting the signing operation...');
  var start = process.hrtime();
  var signedTx = tx.sign(decryptedPrivateKeys);
  console.log(utils.diffTime(start) + ' secs');
  assert(signedTx.verify(), 'Tx sign operation failed.');

  writeOutputFile(outputFile, signedTx, function(err) {
    if(err) {
      throw err;
    }
  });

});

#!/usr/bin/env node

var program = require('commander');
var path = require('path');
var fs = require('fs');
var async = require('async');
var utils = require('../util/crypto-functions.js');
var bitcore = require('bitcore-lib');
var Transaction = bitcore.Transaction;

program
  .option('-f, --walletfile <walletfile>', 'Wallet file to refer to for private keys. Default: ~/.wallet.json')
  .usage('[options] e.g. wallet-sign-nonhd -f wallet.json <input tx file> <output signed tx file>')
  .parse(process.argv);

var args = program.args;
if (!args[0]) {
  program.help();
} else if (args[1] && fs.existsSync(args[1])) {
  console.error('Output file: "' + args[1] + '" already exists, not over-writing, aborting.');
  process.exit(-1);
}

var walletFile = program.walletfile ?
  path.resolve(__dirname, '../' + program.walletfile) :
  process.env.HOME + '/.wallet.json';
var inputFile = path.resolve(__dirname, '../' + args[0]);
var extraFields = ['network', 'salt', 'derivationMethod', 'rounds', 'masterKeyCt'];

function readInputFiles(file1, file2) {
  return [file1, file2].map(function(file) {
    return require(file);
  });
}

function createWalletMap(wallet) {
  var res = {};
  for(var i = 0; i < wallet.length; i++) {
    if (hasNeededFields(res, extraFields)) {
      break;
    }
    var entry = wallet[i];
    if (entry.network) {
      res.network = entry.network;
    } else if (entry.salt) {
      res.salt = entry.salt;
      res.derivatonMethod = entry.derivatonMethod;
      res.rounds = entry.rounds;
      res.masterKeyCt = entry.cipherText;
    }
  }
  if (!hasNeededFields(res, extraFields)) {
    return;
  }
  wallet.forEach(function(key) {
    if (key.pubKey) {
      res[key.pubKey] = key;
    }
  });
  return res;
}

function hasNeededFields(item, fields) {
  if (Object.keys(item).length === fields.length) {
    fields.forEach(function(field) {
      if (!item[field]) { return false; }
    });
    return true;
  }
  return false;
}


function createTx(txData) {
  return new Transaction(txData.tx);
}

function decryptMasterKey(walletMap, callback) {
  utils.getPassphrase(function(passphrase) {
    utils.decryptSecret({
      passphrase: passphrase,
      salt: walletMap.salt,
      derivationOptions: {
        rounds: walletMap.rounds
      }
    }, function(err, hashedPassphrase) {
      if(err) {
        return callback(err);
      }
      utils.decrypt({
        key: hashedPassphrase
      }, callback);
    });
  });
}

function decryptPrivateKeys(keys, walletMap, callback) {
  decryptMasterKey(walletMap, function(err, plainTextMasterKey) {
    if(err) {
      return callback(err);
    }
    async.mapLimit(keys, 10, function(key, next) {

      if (extraFields.indexOf(key) !== -1) {
        next();
      }

      utils.decrypt({
        cipherText: walletMap[key].cipherText,
        key: plainTextMasterKey,
        iv: bitcore.crypto.Hash.sha256sha256(new Buffer(walletMap[key].pubKey, 'hex'))
      }, next);

    }, function(err, res) {
      if(err) {
        return callback(err);
      }
      callback(null, res);
    });
  });
}

function readPrivateKeys(tx, keys) {
  var addresses = tx.inputs.map(function(input) {
    return input.script.toAddress();
  });
  return _.intersect([Object.keys(walletMap), addresses]);
}

function signTx(decryptedPks, tx, callback) {
  return tx.sign(decryptedPks);
}

function writeOutputFile(file, data, callback) {
  fs.open(file, 'wx', function(err, fd) {
    if (err) {
      return callback(err);
    }
    fs.write(fd, data, function(err) {
      if(err) {
        return callback(err);
      }
      callback();
    });
  });
}

var inputs = readInputFiles(inputFile, walletFile);
var tx = createTx(inputs[0]);
console.log(tx);
var walletMap = createWalletMap(inputs[1]);
var pks = readPrivateKeys(inputs);
decryptPrivateKeysForTx(pks, walletMap, function(err, decryptedPks) {
  if(err) {
    return callback(err);
  }
  var signed_tx = signTx(decryptedPks);
  writeOutputFile(tx.checkSerialize(), function(err) {
    if(err) {
      throw err;
    }
    console.log('done');
  });
});

#!/usr/bin/env node

var program = require('commander');
var path = require('path');
var fs = require('fs');
var async = require('async');
var utils = require('../util/crypto-functions.js');
var Hash = require('bitcore-lib').crypto.Hash;
var Transaction = require('bitcore-lib').Transaction;

program
  .option('-f, --walletfile <walletfile>', 'Wallet file to refer to for private keys. Default: ~/.wallet.json')
  .usage('[options] e.g. wallet-sign-nonhd -f wallet.json <input tx file> <output signed tx file>')
  .parse(process.argv);

var args = program.args;
if (!args[0]) {
  program.help();
} else if (args[1] && fs.existsSync(args[1])) {
  console.error('Output file: "' + args[1] + '" already exists, not over-writing, aborting.');
  process.exit(-1);
}

var walletFile = program.walletfile ?
  path.resolve(__dirname, '../' + program.walletfile) :
  process.env.HOME + '/.wallet.json';
var inputFile = path.resolve(__dirname, '../' + args[0]);

function readInputFiles(file1, file2) {
  return [file1, file2].map(function(file) {
    return require(file);
  });
}

function decryptMasterKey(walletMap, callback) {
  utils.getPassphrase(function(err, passphrase) {

    if (err) {
      return callback(err);
    }

    var opts = {
      cipherText: walletMap.masterKey.cipherText,
      passphrase: passphrase,
      salt: walletMap.masterKey.salt,
      derivationOptions: {
        rounds: walletMap.masterKey.rounds,
        method: 0
      }
    };

    utils.decryptSecret(opts, callback);

  });
}

function writeOutputFile(file, data, callback) {
  fs.open(file, 'wx', function(err, fd) {
    if (err) {
      return callback(err);
    }
    fs.write(fd, data, function(err) {
      if(err) {
        return callback(err);
      }
      callback();
    });
  });
}

var inputs = readInputFiles(inputFile, walletFile);
var walletMap = inputs[1];
var txJson = inputs[0];
var tx = new Transaction(txJson.tx);

decryptMasterKey(walletMap, function(err, plainTextMasterKey) {

  if(err) {
    throw err;
  }

  var decryptedPks = [];

  for(var i = 0; i < walletMap.keys.length; i++) {
    var key = walletMap.keys[i];

    decryptedPks.push(utils.decrypt({
      cipherText: key.cipherText,
      key: plainTextMasterKey,
      iv: Hash.sha256sha256(new Buffer(key.pubKey), 'hex')
    }));

  }

  var signedTx = tx.sign(decryptedPks);
  console.log(signedTx.verify());
  //writeOutputFile(tx.checkSerialize(), function(err) {
  //  if(err) {
  //    throw err;
  //  }
  //  console.log('done');
  //});


});
